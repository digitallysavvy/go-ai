# Element Streaming Example

This example demonstrates how to use element streaming to receive individual array elements as they are generated by the AI model.

## Features Demonstrated

1. **Basic Element Streaming** - Stream array elements as they complete
2. **Type-Safe Streaming** - Stream typed structs with full type safety
3. **Callback Handlers** - Use callbacks to react to streaming events
4. **Progress Tracking** - Track streaming progress in real-time

## What is Element Streaming?

Element streaming allows you to receive individual array elements as soon as they are generated, rather than waiting for the entire array to complete. This is particularly useful for:

- **Better UX**: Display results progressively to users
- **Early Processing**: Start processing elements before the full list is ready
- **Reduced Latency**: Users see results faster
- **Live Updates**: Show streaming progress in real-time

## Basic Usage

```go
// Define your element type
type TodoItem struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    Priority    int    `json:"priority"`
}

// Create a schema
todoSchema := schema.NewSimpleJSONSchema(map[string]interface{}{
    "type": "object",
    "properties": map[string]interface{}{
        "title":       map[string]string{"type": "string"},
        "description": map[string]string{"type": "string"},
        "priority":    map[string]string{"type": "integer"},
    },
    "required": []string{"title", "description", "priority"},
})

// Start streaming
result, _ := ai.StreamText(ctx, ai.StreamTextOptions{
    Model:  model,
    Prompt: "Generate a list of 5 todo items",
})

// Create element stream
elementCh := ai.ElementStream[TodoItem](result, ai.ElementStreamOptions[TodoItem]{
    ElementSchema: todoSchema,
})

// Process elements as they arrive
for elem := range elementCh {
    fmt.Printf("[%d] %s\n", elem.Index, elem.Element.Title)
}
```

## Streaming with Callbacks

You can provide callbacks to react to streaming events:

```go
elementCh := ai.ElementStream[TodoItem](result, ai.ElementStreamOptions[TodoItem]{
    ElementSchema: todoSchema,
    OnElement: func(elem ai.ElementStreamResult[TodoItem]) {
        fmt.Printf("Received: %s\n", elem.Element.Title)
    },
    OnError: func(err error) {
        fmt.Printf("Error: %v\n", err)
    },
    OnComplete: func() {
        fmt.Println("Streaming complete!")
    },
})
```

## Element Stream Result

Each element comes with metadata:

```go
type ElementStreamResult[ELEMENT any] struct {
    Element ELEMENT  // The parsed element
    Index   int      // Index in the array (0-based)
    IsFinal bool     // Whether this is the last element
}
```

## Running the Example

1. Set your OpenAI API key:
```bash
export OPENAI_API_KEY="your-api-key-here"
```

2. Run the example:
```bash
go run main.go
```

## How It Works

1. **Incremental Parsing**: As the AI model streams text, the element stream parser attempts to parse partial JSON
2. **Validation**: Each element is validated against the provided schema
3. **Type Conversion**: Valid elements are converted to your Go struct type
4. **Channel Delivery**: Elements are delivered through a Go channel as they complete

## Use Cases

1. **Todo Lists**: Stream tasks as they're generated
2. **Product Catalogs**: Display products incrementally
3. **Search Results**: Show results as they arrive
4. **Recommendations**: Stream recommendations in real-time
5. **Code Generation**: Stream code snippets or functions as they complete
6. **Content Creation**: Stream articles, sections, or paragraphs

## Best Practices

1. **Buffer Size**: The element channel has a default buffer of 10. For high-throughput scenarios, consider the buffer size.
2. **Error Handling**: Always provide an `OnError` callback to handle parsing errors gracefully.
3. **Schema Validation**: Use strict schemas with required fields to ensure data quality.
4. **Context Cancellation**: The streaming respects context cancellation, so you can abort early if needed.
5. **Type Safety**: Use strongly-typed structs for better compile-time safety and IDE support.

## Performance Considerations

- Element streaming adds minimal overhead to the streaming process
- Parsing happens incrementally as chunks arrive
- Memory usage is proportional to the size of individual elements, not the entire array
- Failed validations are skipped efficiently

## Comparison with Regular Streaming

**Regular Text Streaming:**
```go
result, _ := ai.StreamText(ctx, opts)
text, _ := result.ReadAll()
var items []TodoItem
json.Unmarshal([]byte(text), &items) // Wait for entire response
```

**Element Streaming:**
```go
result, _ := ai.StreamText(ctx, opts)
elements := ai.ElementStream[TodoItem](result, opts)
for elem := range elements { // Get items as they complete
    processItem(elem.Element)
}
```

Element streaming provides a better user experience and enables real-time processing.
